#预构建解决问题：

1.需要将它转换成 ESM 格式的产物 2.请求瀑布流问题：在这种依赖层级深、涉及模块数量多的情况下，会触发成百上千个网络请求
，Chrome 对同一个域名下只能同时支持 6 个 HTTP 并发请求的限制，
在进行依赖的预构建之后，lodash-es 这个库的代码被打包成了一个文件，这样请求的数量会骤然减少，页面加载也快了许多。

#依赖预构建

一是将其他格式(如 UMD 和 CommonJS)的产物转换为 ESM 格式，使其在浏览器通过 <script type="module"><script>的方式正常加载。
二是打包第三方库的代码，将各个第三方库分散的文件合并到一起，减少 HTTP 请求数量，避免页面加载性能劣化。

#两件事情全部由性能优异的 Esbuild (基于 Golang 开发)

#预构建开启
自动开启： 1.根目录下的 node_modules 中发现.vite 目录，这就是预构建产物文件存放的目录。 2.第三方包的引入路径已经被重写 3.对于依赖的请求结果，Vite 的 Dev Server 会设置强缓存: 4.除了 HTTP 缓存，Vite 还设置了本地文件系统的缓存，所有的预构建产物默认缓存在 node_modules/.vite
手动开启 #自定义配置详解 --optimizeDeps

1.配置 entries 入口文件（支持 glob 语法）,Vite 会根据应用入口(entries)自动搜集依赖，然后进行预构建不一定百分百找到

2.添加依赖 include --强制预构建的依赖项：
动态 import，动态 import 的路径只有运行时才能确定，无法在预构建阶段被扫描出来。
（二次预构建：Vite 运行时发现了新的依赖，随之重新进行依赖预构建，并刷新页面-导致重新与构建流程，重新刷新页面，重新请求，成本过高）

3. 手动 exclude：用于将某些依赖从预构建的过程中排除

#第三方包出现问题怎么办
